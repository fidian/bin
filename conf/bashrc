#!/bin/bash

# Check for a BSD install (Mac OS X)
ls --color=auto > /dev/null 2>&1

if [ $? -ne 0 ]; then
	GNU="false"
else
	GNU="true"
fi

# Add some directories to the path if they exist.
# Add BPM first, in front of /usr/bin
for D in "$HOME/bin/bpm"; do
    if [[ -d "$D" ]]; then
        PATH="$D:$PATH"
    fi
done

for D in "$HOME/bin" "$HOME/.local/bin" "$HOME/bin/packer" "$HOME/bin/node_modules/.bin" "$HOME/node_modules/.bin" "$HOME/.bpm/.bin"; do
	if [[ -d "$D" ]]; then
		PATH+=":$D"
	fi
done

export PATH


if $GNU; then
	alias dir='ls -lF --color=auto'
	alias ls='ls -F --color=auto'
else
	alias dir='ls -lFG'
	alias ls='ls -FG'
fi

alias del='gvfs-trash'
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias mysqlrepair_all='mysqlrepair -A --auto-repair -g -m -o -r'
alias mysqlcheck_all='mysqlcheck --auto-repair --check --optimize --all-databases'
alias screen='screen -xRR'
alias ppid='ps -o ppid --no-headers -p'
alias ..='~/bin/dot-dot'
alias cws='. ~/cws-cloud/cws.sh'

# Check for our program checker, then check for programs
TEST_FOR_PROGRAM=~/bin/test-for-program

if [ ! -z "$BASH_SOURCE" ]; then
	P="$(dirname "$BASH_SOURCE")/../test-for-program";
	if [ -f "$P" ]; then
		TEST_FOR_PROGRAM="$P"
	fi
fi

if $TEST_FOR_PROGRAM 'less'; then
	export PAGER=less
else
	alias less=more
fi

if $TEST_FOR_PROGRAM 'vim'; then
	alias vi='vim'

    if [[ -x "$HOME/bin/editor" ]]; then
        export EDITOR="$HOME/bin/editor"
    else
        export EDITOR=vim
    fi
else
	export EDITOR=vi
fi


# Below are the color init strings for the basic file types. A color init
# string consists of one or more of the following numeric codes:
# Attribute codes:
# 00=none 01=bold 04=underscore 05=blink 07=reverse 08=concealed
# Text color codes:
# 30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white
# Background color codes:
# 40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white
LS_COLORS="bd=40;33;01" # block devide driver
LS_COLORS+=":cd=40;33;01" # character device driver
LS_COLORS+=":di=01;34" # directory
LS_COLORS+=":do=40;33;01" # door
#LS_COLORS+=":ec=" # ENDCODE
LS_COLORS+=":ex=01;32" # executable file
LS_COLORS+=":fi=00" # file
#LS_COLORS+=":lc=" # LEFTCODE
LS_COLORS+=":ln=01;36" # symbolic link; if set to "target" then it inherits the color of the file to which it points
LS_COLORS+=":mi=01;05;37;41" # missing?
LS_COLORS+=":no=00" # global default; everything should override this
LS_COLORS+=":or=01;05;37;41" # symlink to non-stat'able file
LS_COLORS+=":ow=30;42" # other-writable dir (o+w)
LS_COLORS+=":pi=40;33" # pipe / FIFO
#LS_COLORS+=":rc=" # RIGHTCODE
LS_COLORS+=":sg=30;43" # setgid (g+s)
LS_COLORS+=":so=01;35" # socket
LS_COLORS+=":st=37;44" # sticky dir (+t)
LS_COLORS+=":su=37;41" # setuid (u+s)
LS_COLORS+=":tw=30;42" # sticky, other-writable dir (+t,o+w)
#LS_COLORS+=":wo=" # WRITEOTHERS (dirs)
#LS_COLORS+=":wt=" # WRITEOTHERSTICKY

# per extension settings
# -- executables are bright green
for T in bat btm cmd com csh exe sh; do
	LS_COLORS+=":*.${T}=01;32"
done
# -- archives are bright red
for T in 7z ace arj bz bz2 cpio deb dz gz jar lzh lzma rar rpm rz svgz tar taz tbz2 tgz tz z Z zip zoo; do
	LS_COLORS+=":*.${T}=01;31"
done
# -- images are bright magenta
for T in asf avi bmp dl flc fli gif gl jpeg jpg m2v m4v mkv mng mov mp4 mp4v mpeg mpg nuv ogm pbm pcx pgm png ppm qt rm rmvb svg tga tif tiff vob wmv xbm xcf xpm xwd yuv; do
	LS_COLORS+=":*.${T}=01;35"
done
# -- html, php are bright yellow
for T in htm html php; do
	LS_COLORS+=":*.${T}=01;33"
done
# -- audio files are bright cyan
for T in aac au flac mid midi mka mp3 mpc ogg ra wav; do
	LS_COLORS+=":*.${T}=01;36"
done
export LS_COLORS


# History and searching history
HISTCONTROL=ignoreboth
HISTFILE=${HOME}/.bash_history
HISTFILESIZE=500
HISTIGNORE="&:[ ]*:exit"
HISTSIZE=500
HISTTIMEFORMAT="%h %d %H:%M:%S> "
export HISTCONTROL HISTFILE HISTFILESIZE HISTIGNORE HISTSIZE HISTTIMEFORMAT
shopt -s histappend # Always append to the history, never overwrite
shopt -s cmdhist # Save multi-line commands as a single command
stty stop "" # Prevent Ctrl-S from being software flow control XOFF
bind space:magic-space # Press space to expand all ! expansions

# Color Variables for Prompt
# Lots of info at http://networking.ringofsaturn.com/Unix/Bash-prompts.php
NONE='\[\033[00m\]'
HBLU='\[\033[01;34m\]'
GRN='\[\033[00;32m\]'
YEL='\[\033[00;33m\]'
PRPL='\[\033[00;35m\]'
RED='\[\033[00;31m\]'

# When the previous command showed an error, report it.
bash_prompt_error() {
    if [[ $1 -ne 0 ]]; then
        echo "[ERR $1] "
    fi
}


# add info about git branch to the prompt
bash_prompt_git() {
	local BRANCH REF
	REF="$(git rev-parse --short HEAD 2> /dev/null)"

	if [[ -n "$REF" ]]; then
		BRANCH="$(git symbolic-ref HEAD 2> /dev/null)"

		if [[ -n "$BRANCH" ]]; then
			echo -n " (${BRANCH#refs/heads/})"
		else
			echo -n " (detached $REF)"
		fi
	fi
}

# add shortened path to the prompt
bash_prompt_path() {
    local P TILDE

    TILDE='~'
	P="${PWD/#${HOME}/$TILDE}"

	if [ "${#P}" -gt 35 ]; then
		echo -n "â€¦${P: -32}"
	else
		echo -n "${P}"
	fi
}

PS1=""
case "${TERM}" in
	xterm*)
		# Set the title bar to the current directory
		PS1='\[\033]2;\h:\w\007\]'
		;;
	vt100)
		# Eliminate fancy things like colors
		NONE=""
		HBLU=""
		GRN=""
		YEL=""
		PRPL=""
		RED=""
		;;
	*)
		;;
esac
PS1=$RED'$(bash_prompt_error $?)'$NONE$PS1$GRN'\A'$NONE' '$PRPL'\h'$NONE':'$HBLU'$(bash_prompt_path)'$YEL'$(bash_prompt_git)'$NONE
if [ ${UID} -eq 0 ]; then
	PS1=$PS1$RED
fi
export PS1=$PS1'\$'$NONE' '
export PS2=$YEL'>'$NONE' '
export PS3=$YEL'#?'$NONE' '
export PS4=$YEL'+'$NONE' '

stty stop undef # disable control-s and control-q

if [ -f ~/bin/conf/git-flow-completion/git-flow-completion.bash ]; then
	source ~/bin/conf/git-flow-completion/git-flow-completion.bash
fi

# For package building in PPAs
export DEBFULLNAME="Tyler Akins"
export DEBEMAIL="fidian@rumkin.com"

# Load nvm
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"

# Command completions
$TEST_FOR_PROGRAM grunt && eval "$(grunt --completion=bash)"
$TEST_FOR_PROGRAM aws_completer && complete -C '/usr/local/bin/aws_completer' aws

# Clear the error code
:
